use anchor_lang::prelude::*;
use std::mem::size_of;

use characters_program::{program::CharactersProgram, UserAccount};

declare_id!("BrTDHy59xLXR4pFimtoG9CBp4ATgKJpmQtv8wZvb5diQ");

#[program]
pub mod pool {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, dto: InitializePoolDTO) -> ProgramResult {
        let state = &mut ctx.accounts.state;
        state.members = Vec::with_capacity(dto.capacity as usize);
        state.capacity = dto.capacity;
        state.authority = ctx.accounts.authority.key();
        Ok(())
    }

    pub fn join(ctx: Context<Join>) -> ProgramResult {
        let state = &mut ctx.accounts.state;
        let user_key = ctx.accounts.user_account.key();
        if !state.members.contains(&user_key) {
            state.members.push(user_key);
        }
        Ok(())
    }

    pub fn take(ctx: Context<Take>) -> ProgramResult {
        let state = &mut ctx.accounts.state;
        let user_key = ctx.accounts.user_account.key();
        if let Some(i) = state.members.iter().position(|&k| k == user_key) {
            state.members.remove(i);
        }
        Ok(())
    }

    pub fn close(_ctx: Context<Close>) -> ProgramResult {
        msg!("Pool is closed");
        Ok(())
    }
}

#[account]
pub struct ProgramState {
    pub capacity: u8,
    pub authority: Pubkey,
    pub members: Vec<Pubkey>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct InitializePoolDTO {
    pub capacity: u8,
    pub seed: Vec<u8>,
}

#[derive(Accounts)]
#[instruction(dto: InitializePoolDTO)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = authority,
        seeds = [&*dto.seed],
        bump,
        space = 48 + size_of::<Pubkey>() * (dto.capacity as usize),
    )]
    pub state: Account<'info, ProgramState>,
    #[account(mut)]
    pub authority: SystemAccount<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Join<'info> {
    #[account(
        mut,
        constraint =
            state.members.len() < state.capacity as usize
            @ ErrorCode::CapacityExceeded,
    )]
    pub state: Account<'info, ProgramState>,
    #[account(owner = characters_program::ID)]
    // PDA generated by the `characters-program`
    pub user_account: Account<'info, UserAccount>,
    pub characters_program: Program<'info, CharactersProgram>,
}

#[derive(Accounts)]
pub struct Take<'info> {
    #[account(
        mut,
        seeds = [STATE_SEED],
        bump,
    )]
    pub state: Account<'info, ProgramState>,
    pub user_account: Account<'info, UserAccount>,
}

#[derive(Accounts)]
pub struct Close<'info> {
    #[account(
        mut,
        close = authority,
        has_one = authority
            @ ErrorCode::UnathorizedReceiver
    )]
    pub state: Account<'info, ProgramState>,
    #[account(mut)]
    pub authority: SystemAccount<'info>,
}

#[error]
pub enum ErrorCode {
    #[msg(
        "Pool capacity exceeded. Try closing the pool and initializing it with a bigger capacity."
    )]
    CapacityExceeded,
    #[msg("Unathorized receiver for pool closure.")]
    UnathorizedReceiver,
}
